[{"code":"{ }","question":"# Day 1 - BioNix Workshop\n\nLet's start by defining *computational reproducibility* as always obtaining the\nsame output from a computation given the same inputs. In other words,\ncomputational reproducibility is about making computations deterministic*. In\nthe research context, this is important as reproducibility allows others (and\nourselves) to verify and build upon what we have done in future.\n\n# A functional view of things and why Nix is needed\n\nWhat makes reproducibility difficult is the management of *state*, or the\ncontext within with a computation takes place. State manipulation is widespread:\nhow many apps updates or system updates do you recall automatically being\ninstalled over the past year? Do you think your analysis today will be the same\nin one years time if your software stack has changed?\n\nOne way to deal with this problem is to make computations *pure* by forbidding\nthe use of anything that is not explicitly stated as an input. This is the same\nidea of pure functional programming, only at the higher level of executing\nsoftware.\n\nNix effectively enforces purity for software execution by ensuring the software\ncannot access anything outside of the specified inputs. By this way, it can\nguarantee a very high degree of reproducibility. Nix is a general build engine\nmost commonly used for building software today, but as we will see a bit later\nit can also execute computational biology workflows in a pure manner with a\nsmall library called BioNix.\n\n# Pipelines in BioNix\n\n```\n# This is an example pipeline specification to do multi-sample variant calling\n# with the Platypus variant caller. Each input is preprocessed by aligning\n# against a reference genome (defaults to GRCH38), fixing mate information, and\n# marking duplicates. Finally platypus is called over all samples.\n{ bionix ? import <bionix> { }\n, inputs\n, ref ? bionix.ref.grch38.seq\n}:\n\nwith bionix;\nwith lib;\n\nlet\n  preprocess = flip pipe [\n    (bwa.align { inherit ref; })\n    (samtools.sort { nameSort = true; })\n    (samtools.fixmate { })\n    (samtools.sort { })\n    (samtools.markdup { })\n  ];\n\nin\nplatypus.call { } (map preprocess inputs)\n```\n\n# Nix the language\n\nWe will start with learning Nix the language, which is used for specifying\nworkflows. If you are familiar with JSON, it is very similar in terms of\navailable data types but has one very important addition: functions. Let's cover\nthe basic data types and their syntax:\n\n- Booleans: `true` and `false`\n- Strings: `\"this is a string\"`\n- Numbers: `0`, `1.234`\n- Lists: `[ 0 1.234 \"string\" ]`\n- Attribute sets: `{ a = 5; b = \"something else\"; }`\n- Comments: `# this is a comment`\n- Functions: `x: x + 1`\n- Variable binding: `let x = 5; in x #=> 5`\n- Function application: `let f = x: x + 1; in f 5 #=> 6`\n- File paths: `/path/to/file`\n\nSome common operators:\n- Boolean conjunctions and disjunctions: `true || false #=> true` `true && false #=> false`\n- Ordering: `3 < 3 #=> false`, `3 <= 3 #=> true`\n- Conditionals: `if 3 < 4 then \"a\" else \"b\" #=> a`\n- Addition and subtraction: `3 + 4 #=> 7`, `3 - 4 #=> -1`\n- Multiplication and division: `3 * 4 #=> 12`, `3.0 / 4 #=> 0.75`\n- String concatenation: `\"hello \" + \"world\" #=> \"hello world\"`\n- String interpolation: `\"hello ${\"world\"}\" #=> \"hello world\"`, `\"1 + 2 = ${toString (1 + 2)}\" #=> \"1 + 2 = 3\"`\n- Attribute set unions: `{ a = 5; } // { b = 6; } #=> { a = 5; b = 6; }`\n\n# About this interface\n\nThis workshop uses [A tour of nix](https://github.com/nixcloud/tour_of_nix) with\nsome altered content for the purposes of learning enough of Nix the language to\nwrite workflows in BioNix during the second part. Click next to continue to the\nexercises.\n","solution":"{ }","topic":"Day 1 - BioNix workshop"},{"code":"# code goes here\n{\n  v=\"\";\n}\n","question":"## Usability\n1. You read the description/text on the `right pane`\n  (That is what you are doing right now).\n\n2. You write/fix code on the `left pane`:\n\n  * First thing, **complete v on the left, like:**\n\n    v = \"understood\";\n\n  * Click `run` and if the grey 'output-box' turns\n\n    * **green**\n\n    Everything is good! Change **v** to something else and hit `run` again!\n\n    * **red**\n\n    You have to fix something! If you can't think of what\n    we want from you, then, and only then, click the `solution`\n    button and adapt your solution.\n\n3. Finally there is the `reset` button. If you screwed the code,\n  just hit `reset`.\n\n  **Note:** Using `reset` you will lose the text you had\n  there before.\n\n","solution":"{ v=\"understood\"; }","topic":"How it works..."},{"code":"let \n  h = \"Hello\";\n  w = \"World\";\nin\n{\n  helloWorld = h + X + X;\n}\n","question":"A simple introduction to `Strings` in Nix:\n\n* Complete the `String` to 'Hello World', replace all 'X' with \nvariables or `Strings`.\n\n## Let expressions\n\nThe let expression is composed of:\n\n    let <bindings> in <body>\n    \nThe bindings are a series of definitions separated by semi-colons. \n\n**Note:** In Nix you can use the `let`-construct to bind a `value` to a \n`variable` but also a `function`. In the `<body>` you can then\nrefer to the `bound values`, even multiple times.\n\nMore at [Nix by example part1](https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55#8310) by James Fisher.\n","solution":"let \n  h = \"Hello\";\n  w = \"World\";\nin\n{\n  helloWorld = h + \" \" + w;\n}\n","topic":"Hello World"},{"code":"let \n  h = \"Hello\";\nin\n{\n  helloWorld = \"${h} \"; # Modify this line\n}\n","question":"Nix can also insert `Strings` with ${variable}.\n \n * Complete the `String` to 'Hello World'.","solution":"let \n  h = \"Hello\";\nin\n{\n  helloWorld = \"${h} World\";\n}\n","topic":"Strings"},{"code":"let \n  h = \"Strings\";\n  value = 4;\nin\n{\n  helloWorld = \"${h} ${value} the win!\";\n}\n","question":"Inserting `Strings` using the pattern `${variable}` works great \nwith `Strings`. But `${}` can do more. You can even run functions within it.\n\nUse this and the builtin function `toString` to make the code work.\n\n**Note:** More builtin functions can be found in the [Nix manual](http://nixos.org/nix/manual/#ssec-builtins).\n","solution":"let \n  h = \"Strings\";\n  value = 4;\nin\n{\n  helloWorld = \"${h} ${toString value} the win!\";\n}\n","topic":"Integer to string"},{"code":"let\n  f = \"f\";\n  o = \"o\";\n  func = a: b: c: XXXX; \nin\n{\n  foo = func f o \"o\";\n}\n","question":"Next we will have a look into `functions` and how they are defined and called:\n\n* Write a `function` that consumes 3 `Strings` and combines them to one. \n\n**Note:** Strings concatenation can be done with the '+' operator.","solution":"let\n  f = \"f\";\n  o = \"o\";\n  func = a: b: c: a+b+c; \nin\n{\n  foo = func f o \"o\";\n}\n","topic":"Functions: Introduction"},{"code":"let\n  f = \"f\";\n  o = \"o\";\n  func = {a, b, c}: XXXX;\nin\n{\n  foo = func {a=f; XXXXX};\n}\n","question":"This time we pass an `attribute set` to define the `function's` input arguments.\n\n* Write a function that consumes 3 `Strings` and combines them to one.\n\n**Note:** `Attribute Sets` are a set of key value pairs. \n\nAn example for an `Attribute Set` would be: **{a=f;b=o;}**","solution":"let\n  f = \"f\";\n  o = \"o\";\n  func = {a, b, c}: a+b+c; \nin\n{\n  foo = func {a=f; b=o; c=o;};\n}\n","topic":"Functions with 'attribute sets'"},{"code":"let\n  min = XX #modify these\n  max = XX #two lines only\nin\n{\n  ex0 = min 5 3;\n  ex1 = max 9 4;\n}\n","question":"## Implementing your first function!\nWhat to do:\n\n* Implement the `min` and the `max` function using `if X then Y else Z`\n\n","solution":"let\n  min = x: y: if x < y then x else y;\n  max = x: y: if x > y then x else y;\nin\n{\n  ex0 = min 5 3;\n  ex1 = max 9 4;\n}\n# make stdenv.lib available\n# with import <nixpkgs> { };\n# {\n#   # finally make use of it\n#   ex0 = stdenv.lib.min 5 3;\n#   ex1 = stdenv.lib.max 9 4;\n# }\n","topic":"Functions: your part..."},{"code":"let\n  func = {a ? \"f\", b , c }: a+b+c; #only modify default values on this line!\nin\nrec {\n  foo = func {b=\"o\"; c=\"o\";}; #must evaluate to \"foo\"\n  bar = func {a=\"b\"; c=\"r\";}; #must evaluate to \"bar\"\n  foobar = func {a=foo;b=bar;}; #must evaluate to \"foobar\"\n}\n","question":"When passing an `attribute set` to `function`, you can set default values.\n\nDoing so, allows the function to be called without that parameter, making \nit optional.\n\n**Note:** A default value is defined with a '?'. \n\nNow:\n\n* Change the `function` 'func' in a way that **foobar** is \nevaluated to **'foobar'**.\n\n","solution":"let\n  func = {a ? \"f\", b ? \"a\", c ? \"\"}: a+b+c; #only modify default values on this line!\nin\nrec {\n  foo = func {b=\"o\"; c=\"o\";}; #must evaluate to \"foo\"\n  bar = func {a=\"b\"; c=\"r\";}; #must evaluate to \"bar\"\n  foobar = func {a=foo;b=bar;}; #must evaluate to \"foobar\"\n}\n\n","topic":"Functions: default values"},{"code":"rec {\n  x = \"a\";\n  y = x;\n}\n","question":"`Sets` or `attribute sets` are really **the core of the Nix language**, since ultimately the language \nis is all about creating derivations, which are really \njust `sets of attributes` to be passed to build scripts.\n\nSets are just a list of name/value pairs (called attributes) \nenclosed in curly brackets, where each value is an arbitrary \nexpression terminated by a semicolon. For example:\n\n    { x = 123;\n      text = \"Hello\";\n      y = f { bla = 456; };\n    }\n\nThis defines a set with attributes named x, text, y. The order of the attributes is irrelevant. An attribute name may only occur once.\n\nNow:\n\n* Find out what the `rec` keyword does and what the difference to an `attribute set` without `rec` is.\n* Delete the `rec` before the `attribute set` and observe the different behaviour of the nix interpreter.\n\n**Hint:** You find the answer within the solution section.\n\n**Note:** That is all for now, but you can continue reading in the [nix documentation](http://nixos.org/nix/manual/#ssec-values).\n\n","solution":"rec {\n  x = \"a\";\n  y = x;\n}\n#Recursive sets are just normal sets, but the attributes can refer to each other.\n#Be aware of infinit recursions. They are not possible!\n#rec {\n#  x = y;\n#  y = x;\n#} Does not Work.","topic":"Attribute sets: rec"},{"code":"let\n  x = { a=\"bananas\"; b= \"pineapples\"; };\n  y = { a=\"kakis\"; c =\"grapes\";};\n  z = { a=\"raspberrys\"; c= \"oranges\"; };\n\n  func = {a, b, c ? \"another secret ingredient\"}: \"A drink of: \" + \n    a + \", \" + b + \" and \" + c;\nin\nrec {\n  ex00=func ( x );  \n  # hit 'run', you need the output to solve this!\n  #ex01=func (y // X );  \n  #ex02=func (x // { X=\"lychees\";});\n  #ex03=func (X // x // z);\n}\n\n","question":"Since programming in Nix is all about `attribute sets` it is important\nto know how to `merge` these using the `//` operator.\n\n    l = {a=\"A\"; b=\"B\";} // {a=\"aaa\"};\n\nwill evaluate to:\n\n    l = {a=\"aaa\"; b=\"B\";};\n    \nas the later `set` overwrites the attributes from the earlier one.\n\nNow:\n\n* Every exercise `ex00, ex01, ...` should evaluate to what it is compared \nto, just see the output after hitting 'run' once.\n\n","solution":"with import <nixpkgs> { };\nlet\n  x = { a=\"bananas\"; b= \"pineapples\"; };\n  y = { a=\"kakis\"; c =\"grapes\";};\n  z = { a=\"raspberrys\"; c= \"oranges\"; };\n\n  func = {a, b, c ? \"another secret ingredient\"}: \"A drink of: \" + \n    a + \", \" + b + \" and \" + c;\nin\nrec {\n  ex00=func (x);  \n  ex01=func (y // x );  \n  ex02=func (x // { c=\"lychees\";});\n  ex03=func (z // x // z);\n}\n","topic":"Attribute sets: merging"},{"code":"let\n  attrSet = {x = \"a\"; y = \"b\"; b = {t = true; f = false;};};\n  attrSet.c = 1;\n  attrSet.d = null;\n  attrSet.e.f = \"g\";\nin\nrec {\n  #boolean\n  ex0 = attrSet.b.t;\n  #equal\n#  ex01 =  \"a\" == attrSet.XX; \n  #unequal \n#  ex02 = !(\"b\" != attrSet.XX );\n  #and/or/neg\n#  ex03 = ex01 && !ex02 || ! attrSet.XX;\n  #implication\n#  ex04 = true -> attrSet.XX;\n  #contains attribute\n#  ex05 = attrSet ? XX;\n#  ex06 = attrSet.XX ? f;\n}\n","question":"To learn the basic syntax of Nix, replace every XX in the function body\nwith values from the variable `attrSet` bound in the let scope.\n\nEach individual exercise `ex00, ex01, ...` should evaluate to `true`. \n\n**Note:** Remove the `#` to uncomment the exercises as you proceed.\n\nSee [Nix documentation](http://nixos.org/nix/manual/#ssec-values) \nfor more details on `attribute sets`.\n\n","solution":"let\n  attrSet = {x = \"a\"; y = \"b\"; b = {t = true; f = false;};};\n  attrSet.c = 1;\n  attrSet.d = null;\n  attrSet.e.f = \"g\";\nin\nrec {\n  ex0 = attrSet.b.t;\n  #equal\n  ex01 = \"a\" == attrSet.x;\n  #unequal \n  ex02 = !(\"b\" != attrSet.y);\n  #and/or/neg\n  ex03 = ex01 && !ex02 || !attrSet.b.f;\n  #implication\n  ex04 = true -> attrSet.b.t;\n  #contains attribute\n  ex05 = attrSet ? e;\n  ex06 = attrSet.e ? f;\n}","topic":"Attribute sets and booleans"},{"code":"with import <nixpkgs> { };\nwith stdenv.lib;\nlet\n  list = [2 \"4\" true true {a = 27;} 2];\n  f = x: isString x;\n  s = \"foobar\";\nin\n{\n  #replace all X, everything should evaluate to true\n  ex00 = isList X;\n  ex01 = elemAt list 2 == X;\n  ex02 = length list == X;\n  ex03 = last list == X;\n  ex04 = filter f list == [ XX ];\n  ex05 = head list == X;\n  ex06 = tail list == [ XXX ];\n  ex07 = remove true list == [ XXX ];\n  ex08 = toList s == [ XXX ];\n  ex09 = take 3 list == [ XXX ];\n  ex10 = drop 4 list == [ XXX ];\n  ex11 = unique list == [ XXX ];\n  ex12 = list ++ [\"x\" \"y\"] == [ XXX ];\n}\n","question":"To learn the basic syntax replace every XX in the function body with values from the let scope.\n\n\nEvery exercise should evaluate to true.","solution":"with import <nixpkgs> { };\nwith stdenv.lib;\nlet\n  list = [2 \"4\" true true {a = 27;} 2];\n  f = x: isString x;\n  s = \"foobar\";\nin\n{\n  #replace all X, everything should evaluate to true\n  ex00 = isList list;\n  ex01 = elemAt list 2 == true;\n  ex02 = length list == 6;\n  ex03 = last list == 2;\n  ex04 = filter f list == [\"4\"];\n  ex05 = head list == 2;\n  ex06 = tail list == [\"4\" true true {a = 27;} 2];\n  ex07 = remove true list == [2 \"4\" {a = 27;} 2];\n  ex08 = toList s == [s];\n  ex09 = take 3 list == [2 \"4\" true];\n  ex10 = drop 4 list == [{a = 27;} 2];\n  ex11 = unique list == [2 \"4\" true {a = 27;}];\n  ex12 = list ++ [\"x\" \"y\"] == [2 \"4\" true true {a = 27;} 2 \"x\" \"y\"];\n}\n","topic":"Lists"},{"code":"let \n  myImport = import <nixpkgs> {};\n  x = 123; \n  as = { a = \"foo\"; b = \"bar\"; };\n  \nin with as; { \n  inherit x; #example\n  #fix line below: we want a and b in this scope\n  inherit X; \n  #also fix this line\n  z = XXX.lib.isBool true;\n}\n","question":"These 3 keywords can be confused pretty easily. Since we are using them\na lot in `A tour of Nix` we need to introduce them properly.\n\n## With\n\nA with-expression, introduces the `set e1` into the lexical scope of the `expression e2`. \n\n    let \n      as = { x = \"foo\"; y = \"bar\"; };\n    in \n      with as; x + y\n\n## Import\n\nLoad, parse and return the Nix expression in the file path. \n`import` implements Nixâ€™s module system: you can put any Nix expression (such as a set or a function) in a separate file, and use it from Nix expressions in other files.\n\n    rec {\n      x = 123;\n      y = import ./foo.nix;\n    }\n\n## Inherit\nThe `inherit` keyword causes the specified `attributes` to be bound to whatever \nvariables with the same name happen to be in scope.\n\n    let \n      x = 123; \n    in\n    { \n      inherit x;\n      y = 456;\n    }\n","solution":"let \n  myImport = import <nixpkgs> {};\n  x = 123; \n  as = { a = \"foo\"; b = \"bar\"; };\n  \nin with as; { \n  inherit x;\n  inherit a b;\n  z = myImport.lib.isBool true;\n}\n","topic":"Inheriting with imports-confusion!"},{"code":"let\n  bar = [\"bar\" \"foo\" \"bla\"];\n  numbers = [1 2 3 4];\nin\n{\n  #multiplies every number by 2\n  example = map (n: n * 2) numbers; \n  #complete this\n#  foobar = map ( XXX ) XXXX;\n}\n","question":"A function called `builtin.map` exists.\n\nThe `map-function` requires these arguments: a `function` and a `list`. \nIt evaluates the given function on every element of the given list. \n\nIn the example it is used to multiply \nevery number in a list with 2. \n\nYour job:\n\n* Use the map function to extend every `string` in **bar** with \"bar\". \n\n**Note:** You can modify the `Strings` in any way. \nThey don't have to evaluate to 'foobar' (nor should they).","solution":"let\n  bar = [\"bar\" \"foo\" \"bla\"];\n  numbers = [1 2 3 4];\nin\n{\n  #multiplies every number by 2\n  example = map (n: n * 2) numbers; \n  #complete this\n  foobar = map (x: x + \"bar\") bar;\n}","topic":"Map"},{"code":"with import <nixpkgs> { };\nlet\n  list = [\"a\" \"b\" \"a\" \"c\" \"d\" \"a\"];\n  countA = lib.fold XXX;\nin\nrec {\n  example = lib.fold (x: y: x + y) \"\" [\"a\" \"b\" \"c\"]; #is \"abc\"\n  result = countA list; #should be 3\n}\n","question":"`Fold` is a binary function that uses the function 'f' between successive\nelements of `list` with 'z' as the starting value,\n\ni.e., `fold f z [x_1 x_2 ... x_n] == f x_1 (f x_2 ... (f x_n z))`\n\n**Note:** There is **fold left** and **fold right** and `lib.fold`\nimplements **fold right**.\n\n**Note:** More information about `fold` can be found at:\n[Wikipedia](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29)\n\nNow:\n\n* use `fold` to write a function that counts all `strings`\nwith value \"a\" in a given `list`.\n\n","solution":"\n# use fold to write a function that counts all \"a\" in a list\nwith import <nixpkgs> { };\nlet\n  list = [\"a\" \"b\" \"a\" \"c\" \"d\" \"a\"];\n  countA = lib.fold (x: y: if x == \"a\" then 1 + y else y) 0;\nin\nrec {\n  example = lib.fold (x: y: x + y) \"\" [\"a\" \"b\" \"c\"]; #is \"abc\"\n  result = countA list; #should be 3\n}\n\n\n","topic":"Fold: Introduction"},{"code":"with import <nixpkgs> { }; \nrec {\n  made_it = \"it is done\";\n}\n","question":"## It is done!\nCongratulations! You reached the end of this course and you made it!\n\n**We hope you liked 'A tour of Nix'!** If you want to **contact us**, \nplease write an email to either:\n\n* [Joachim Schiele](mailto:js@lastlog.de)\n* [Paul Seitz](mailto:paul.m.seitz@gmail.com)\n\n\n## Further reading\n\n* [Nix by example - Part 1](https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55)\n\n  Parse trees, evaluation order, composite data-types, laziness, conditionals, Let expressions, and much more...\n\n* [Luca Bruno's nix pill(s)](http://lethalman.blogspot.de/2014/07/nix-pill-1-why-you-should-give-it-try.html)\n  \n  The Nix Pills are a wonderful introduction into Nix programming and you will \n  have much joy reading them!\n  \n* [NixPkgs manual](https://nixos.org/nixpkgs/manual) \n\n  Covers topics as: buildPhases, override(s) and support for specific \n  programming languages\n \n* [NixOS Wiki](https://nixos.org/wiki/Main_Page)\n\n  The Wiki contains a lot of practical articles, like the \n  [Cheatsheet](https://nixos.org/wiki/Cheatsheet)\n\n\n## Contributing\n\nNow this is actually quite easy! \n\n ??PAYPAL??\n\n### Manual editing\nDownload <https://nixcloud.io/tour/questions.json> and open it in the \neditor of your choise.\n\n### Using the inline editor\n\nShortcuts:\n\n* `ctrl+,` - loads markdown into the editor\n* `ctrl+.` - compiles markdown2html into the right side\n\n  **Note:** do this twice and the editor is restored to the previous state!\n\n* `ctrl+i` - reset the editor to the default content\n* `ctrl+s` - save the questions to `questions.json` into you \n  `downloads` directory\n  \nIf you want to add new questions, use the javascript console. \n\n**Warning:** `ctrl+shift+i` won't work in chrome, so use the mouse with \nRMB to `inspect element`. From that javascript console you can extend the `questions` \nobject, which holds all the questions.\n\n**Warning:** You might want to play with the workflow for some time as\nyou can easily 'overwrite' or 'reset' your contributions by accident!","solution":"with import <nixpkgs> { }; \nrec {\n  made_it = \"it is done\";\n}\n","topic":"The end"}]