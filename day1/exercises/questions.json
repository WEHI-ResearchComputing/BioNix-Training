[{"code":"{ }","question":"# Day 1 - BioNix Workshop\n\nLet's start by defining *computational reproducibility* as always\nobtaining the same output from a computation given the same inputs. In\nother words, computational reproducibility is about making computations\n*deterministic*.  In the research context, this is important as\nreproducibility allows others (and ourselves) to verify and build upon\nwhat we have done in future.\n\n# A functional view of things and why Nix is needed\n\nWhat makes reproducibility difficult is the management of *state*, or\nthe context within with a computation takes place. State manipulation is\nwidespread:  how many apps updates or system updates do you recall\nautomatically being installed over the past year?  Do you think your\nanalysis today will be the same in one years time if your software stack\nhas changed?\n\nOne way to deal with this problem is to make computations *pure* by forbidding\nthe use of anything that is not explicitly stated as an input. This is\nthe same idea of pure functional programming, only at the higher level of\nexecuting software.\n\nNix effectively enforces purity for software execution by ensuring the software\ncannot access anything outside of the specified inputs. By this way, it can\nguarantee a very high degree of reproducibility. Nix is a general build engine\nmost commonly used for building software today, but as we will see a bit later\nit can also execute computational biology workflows in a pure manner with a small\nlibrary called BioNix.\n\n# Nix the language\n\nWe will start with learning Nix the langauge, which is used for\nspecifying workflows. If you are familar with JSON, it is very similar\nin terms of availble data types but has one very important addition:\nfunctions. Let's cover the basic data types and their syntax:\n\n- Strings: `\"this is a string\"`\n\n- can be multiline:\n```\n''\n  This is a multiline\n  indented\n  string\n''\n```\n\n- Numbers: `0`\n\n# About this interface\n\nThis workshop uses [A tour of\nnix](https://github.com/nixcloud/tour_of_nix) with some altered content\nfor the purposes of learning enough of Nix the language to write\nworkflows in BioNix during the second part. Click next to continue to\nthe exercises.\n\n","solution":"{ }","topic":"Day 1 - BioNix workshop"},{"code":"# code goes here\n{\n  v=\"\";\n}\n","question":"## Usability\n1. You read the description/text on the `right pane`\n  (That is what you are doing right now).\n\n2. You write/fix code on the `left pane`:\n\n  * First thing, **complete v on the left, like:**\n  \n    v = \"understood\";\n    \n  * Click `run` and if the grey 'output-box' turns \n  \n    * **green**\n    \n    Everything is good! Change **v** to something else and hit `run` again!\n  \n    * **red**\n    \n    You have to fix something! If you can't think of what\n    we want from you, then, and only then, click the `solution`\n    button and adapt your solution.\n    \n3. Finally there is the `reset` button. If you screwed the code,\n  just hit `reset`. \n  \n  **Note:** Using `reset` you will lose the text you had\n  there before.\n\n## The shell\n\nWhenever you hit `run`, this happens:\n\n1. javascript writes `the editor's` contents into the file `/test.nix`\n\n2. then it runs `nix-instantiate.js` with:\n\n        -I nixpkgs=nixpkgs/ --eval --strict --show-trace /test.nix\n\n**Note:** If you've got **Nix** or **NixOS** installed natively, then you \ncan also execute this examples on the shell.\n\n## Privacy\n\nWe are:\n* not using **cookies** and \n* **we don't store your results.**\n\nHappy hacking & learning!\n\n**Note:** If you hit `reload` in your browser, everything is gone!\n\n\n\n","solution":"{ v=\"understood\"; }","topic":"How it works..."},{"code":"let \n  h = \"Hello\";\n  w = \"World\";\nin\n{\n  helloWorld = h + X + X;\n}\n","question":"A simple introduction to `Strings` in Nix:\n\n* Complete the `String` to 'Hello World', replace all 'X' with \nvariables or `Strings`.\n\n## Let expressions\n\nThe let expression is composed of:\n\n    let <bindings> in <body>\n    \nThe bindings are a series of definitions separated by semi-colons. \n\n**Note:** In Nix you can use the `let`-construct to bind a `value` to a \n`variable` but also a `function`. In the `<body>` you can then\nrefer to the `bound values`, even multiple times.\n\nMore at [Nix by example part1](https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55#8310) by James Fisher.\n","solution":"let \n  h = \"Hello\";\n  w = \"World\";\nin\n{\n  helloWorld = h + \" \" + w;\n}\n","topic":"Hello World"},{"code":"let \n  h = \"Hello\";\nin\n{\n  helloWorld = \"${h} \"; # Modify this line\n}\n","question":"Nix can also insert `Strings` with ${variable}.\n \n * Complete the `String` to 'Hello World'.","solution":"let \n  h = \"Hello\";\nin\n{\n  helloWorld = \"${h} World\";\n}\n","topic":"Strings"},{"code":"let \n  h = \"Strings\";\n  value = 4;\nin\n{\n  helloWorld = \"${h} ${value} the win!\";\n}\n","question":"Inserting `Strings` using the pattern `${variable}` works great \nwith `Strings`. But `${}` can do more. You can even run functions within it.\n\nUse this and the builtin function `toString` to make the code work.\n\n**Note:** More builtin functions can be found in the [Nix manual](http://nixos.org/nix/manual/#ssec-builtins).\n","solution":"let \n  h = \"Strings\";\n  value = 4;\nin\n{\n  helloWorld = \"${h} ${toString value} the win!\";\n}\n","topic":"Integer to string"},{"code":"let\n  f = \"f\";\n  o = \"o\";\n  func = a: b: c: XXXX; \nin\n{\n  foo = func f o \"o\";\n}\n","question":"Next we will have a look into `functions` and how they are defined and called:\n\n* Write a `function` that consumes 3 `Strings` and combines them to one. \n\n**Note:** Strings concatenation can be done with the '+' operator.","solution":"let\n  f = \"f\";\n  o = \"o\";\n  func = a: b: c: a+b+c; \nin\n{\n  foo = func f o \"o\";\n}\n","topic":"Functions: Introduction"},{"code":"let\n  f = \"f\";\n  o = \"o\";\n  func = {a, b, c}: XXXX; \nin\n{\n  foo = func {a=f; XXXXX\n}\n","question":"This time we pass an `attribute set` to define the `function's` input arguments.\n\n* Write a function that consumes 3 `Strings` and combines them to one.\n\n**Note:** `Attribute Sets` are a set of key value pairs. \n\nAn example for an `Attribute Set` would be: **{a=f;b=o;}**","solution":"let\n  f = \"f\";\n  o = \"o\";\n  func = {a, b, c}: a+b+c; \nin\n{\n  foo = func {a=f; b=o; c=o;};\n}\n","topic":"Functions with 'attribute sets'"},{"code":"let\n  min = XX #modify these\n  max = XX #two lines only\nin\n{\n  ex0 = min 5 3;\n  ex1 = max 9 4;\n}\n","question":"##Implementing your first function!\nWhat to do:\n\n* Implement the `min` and the `max` function using `if () then X else Y`\n\n**Note:** those functions already exist and can be accessed with `lib.min` \nand `lib.max` (don't do this in this exercise).\n \n**Experiments:** \n\n* What happens if you create an infinite recursion call to `min`?\n* Now, instead of calling your `min` and `max` implementation, use `lib.min` and\n`lib.max`. \n\n  The question is actually: what has to be added in order to use `lib`?\n \n ","solution":"let\n  min = x: y: if x < y then x else y;\n  max = x: y: if x > y then x else y;\nin\n{\n  ex0 = min 5 3;\n  ex1 = max 9 4;\n}\n# make stdenv.lib available\n# with import <nixpkgs> { };\n# {\n#   # finally make use of it\n#   ex0 = stdenv.lib.min 5 3;\n#   ex1 = stdenv.lib.max 9 4;\n# }\n","topic":"Functions: your part..."},{"code":"let\n  f = \"f\";\n  o = \"o\";\n  b = \"b\";\n  func = {a ? f, b , c }: a+b+c; #only modify this line!\nin\nrec {\n  foo = func {b=\"o\"; c=o;}; #must evaluate to \"foo\"\n  bar = func {a=b; c=\"r\";}; #must evaluate to \"bar\"\n  foobar = func {a=foo;b=bar;}; #must evaluate to \"foobar\"\n}\n","question":"When passing an `attribute set` to `function`, you can set default values.\n\nDoing so, allows the function to be called without that parameter, making \nit optional.\n\n**Note:** A default value is defined with a '?'. \n\nNow:\n\n* Change the `function` 'func' in a way that **foobar** is \nevaluated to **'foobar'**.\n\n","solution":"let\n  f = \"f\";\n  o = \"o\";\n  b = \"b\";\n  func = {a ? f, b ? \"a\", c ? \"\"}: a+b+c; #Only modify this line! \nin\nrec {\n  foo = func {b=\"o\"; c=o;}; #should be foo\n  bar = func {a=b; c=\"r\";}; #should be bar\n  foobar = func {a=foo;b=bar;}; #should be foobar\n}","topic":"Functions: default values"},{"code":"let\n  arguments = {a=\"f\"; b=\"o\"; c=X; d=X;}; #only modify this line\n  func = {a, b, c, ...}: a+b+c; \n  func2 = args@{a, b, c, ...}: a+b+c+args.d;\nin\n{\n  #the argument d is not used \n  foo = func arguments;\n  #now the argument d is used\n  foobar = func2 arguments;\n}\n","question":"## Ellipsis\n\nFunctions can be called with an `attribute set`, as we have seen.\nThis `attribute set` must contain all required 'function \narguments`.\n\nHowever, such an `Attribute set` can contain additional attributes but\nyou have to add `...` like this:\n\n    func2 = args@{a, b, c, ...}: a+b+c+args.d;\n\n**Note:** `...` is called `ellipsis`.\n\n## @-pattern\n\nInside a function, those `attributes` can be accessed with the \n`@-pattern`.\n\nNow complete the arguments `attribute set`:\n\n  * **foo** must evaluate to 'foo'\n  * **foobar** must evaluate to 'foobar'\n\n","solution":"let\n  arguments = {a=\"f\"; b=\"o\"; c=\"o\"; d=\"bar\";}; #only modify this line\n\n  func = {a, b, c, ...}: a+b+c; \n  func2 = args@{a, b, c, ...}: a+b+c+args.d;\nin\n{\n  #the argument d is not used \n  foo = func arguments;\n  #now the argument d is used\n  foobar = func2 arguments;\n}\n","topic":"Functions: the @-pattern"},{"code":"let\n  func = {a, b, ...}@bargs: if a == \"foo\" then\n    b + bargs.c else b + bargs.x + bargs.y;\nin\n{\n  #complete next line so it evaluates to \"foobar\"\n  foobar = func {a=\"bar\"; XXXXXX} #ONLY EDIT THIS LINE\n}\n","question":"`Attribute sets` can contain additional attributes which are not part of \nthe function definition.\n\nInside a function, those `attributes` can be accessed with the \n`@-pattern`.\n\n**Note:** `bargs@{a, b, ...}:` is equivalent to `{a, b, ...}@bargs:`.\n\nNow complete the last line: \n\n* It should evaluate to 'foobar'\n\n","solution":"let\n  func = {a, b, ...}@bargs: if a == \"foo\" then\n    b + bargs.c else b + bargs.x + bargs.y;\nin\n{\n  #complete next line so it evaluates to \"foobar\"\n  foobar = func {a=\"bar\"; b=\"foo\"; x=\"bar\"; y=\"\";}; \n}\n","topic":"Functions: the @-pattern II"},{"code":"rec {\n  x = \"a\";\n  y = x;\n}\n","question":"`Sets` or `attribute sets` are really **the core of the Nix language**, since ultimately the language \nis is all about creating derivations, which are really \njust `sets of attributes` to be passed to build scripts.\n\nSets are just a list of name/value pairs (called attributes) \nenclosed in curly brackets, where each value is an arbitrary \nexpression terminated by a semicolon. For example:\n\n    { x = 123;\n      text = \"Hello\";\n      y = f { bla = 456; };\n    }\n\nThis defines a set with attributes named x, text, y. The order of the attributes is irrelevant. An attribute name may only occur once.\n\nNow:\n\n* Find out what the `rec` keyword does and what the difference to an `attribute set` without `rec` is.\n* Delete the `rec` before the `attribute set` and observe the different behaviour of the nix interpreter.\n\n**Hint:** You find the answer within the solution section.\n\n**Note:** That is all for now, but you can continue reading in the [nix documentation](http://nixos.org/nix/manual/#ssec-values).\n\n","solution":"rec {\n  x = \"a\";\n  y = x;\n}\n#Recursive sets are just normal sets, but the attributes can refer to each other.\n#Be aware of infinit recursions. They are not possible!\n#rec {\n#  x = y;\n#  y = x;\n#} Does not Work.","topic":"Attribute sets: rec"},{"code":"let\n  x = { a=\"bananas\"; b= \"pineapples\"; };\n  y = { a=\"kakis\"; c =\"grapes\";};\n  z = { a=\"raspberrys\"; c= \"oranges\"; };\n\n  func = {a, b, c ? \"another secret ingredient\"}: \"A drink of: \" + \n    a + \", \" + b + \" and \" + c;\nin\nrec {\n  ex00=func ( x );  \n  # hit 'run', you need the output to solve this!\n  #ex01=func (y // X );  \n  #ex02=func (x // { X=\"lychees\";});\n  #ex03=func (X // x // z);\n}\n\n","question":"Since programming in Nix is all about `attribute sets` it is important\nto know how to `merge` these using the `//` operator.\n\n    l = {a=\"A\"; b=\"B\";} // {a=\"aaa\"};\n\nwill evaluate to:\n\n    l = {a=\"aaa\"; b=\"B\";};\n    \nas the later `set` overwrites the attributes from the earlier one.\n\nNow:\n\n* Every exercise `ex00, ex01, ...` should evaluate to what it is compared \nto, just see the output after hitting 'run' once.\n\n","solution":"with import <nixpkgs> { };\nlet\n  x = { a=\"bananas\"; b= \"pineapples\"; };\n  y = { a=\"kakis\"; c =\"grapes\";};\n  z = { a=\"raspberrys\"; c= \"oranges\"; };\n\n  func = {a, b, c ? \"another secret ingredient\"}: \"A drink of: \" + \n    a + \", \" + b + \" and \" + c;\nin\nrec {\n  ex00=func (x);  \n  ex01=func (y // x );  \n  ex02=func (x // { c=\"lychees\";});\n  ex03=func (z // x // z);\n}\n","topic":"Attribute sets: merging"},{"code":"let\n  attrSet = {x = \"a\"; y = \"b\"; b = {t = true; f = false;};};\n  attrSet.c = 1;\n  attrSet.d = null;\n  attrSet.e.f = \"g\";\nin\nrec {\n  #boolean\n  ex0 = attrSet.b.t;\n  #equal\n#  ex01 =  \"a\" == attrSet.XX; \n  #unequal \n#  ex02 = !(\"b\" != attrSet.XX );\n  #and/or/neg\n#  ex03 = ex01 && !ex02 || ! attrSet.XX;\n  #implication\n#  ex04 = true -> attrSet.XX;\n  #contains attribute\n#  ex05 = attrSet ? XX;\n#  ex06 = attrSet.XX ? f;\n}\n","question":"To learn the basic syntax of Nix, replace every XX in the function body\nwith values from the variable `attrSet` bound in the let scope.\n\nEach individual exercise `ex00, ex01, ...` should evaluate to `true`. \n\n**Note:** Remove the `#` to uncomment the exercises as you proceed.\n\nSee [Nix documentation](http://nixos.org/nix/manual/#ssec-values) \nfor more details on `attribute sets`.\n\n","solution":"let\n  attrSet = {x = \"a\"; y = \"b\"; b = {t = true; f = false;};};\n  attrSet.c = 1;\n  attrSet.d = null;\n  attrSet.e.f = \"g\";\nin\nrec {\n  ex0 = attrSet.b.t;\n  #equal\n  ex01 = \"a\" == attrSet.x;\n  #unequal \n  ex02 = !(\"b\" != attrSet.y);\n  #and/or/neg\n  ex03 = ex01 && !ex02 || !attrSet.b.f;\n  #implication\n  ex04 = true -> attrSet.b.t;\n  #contains attribute\n  ex05 = attrSet ? e;\n  ex06 = attrSet.e ? f;\n}","topic":"Attribute sets and booleans"},{"code":"with import <nixpkgs> { };\nwith stdenv.lib;\nlet\n  list = [2 \"4\" true true {a = 27;} 2];\n  f = x: isString x;\n  s = \"foobar\";\nin\n{\n  #replace all X, everything should evaluate to true\n  ex00 = isList X;\n  ex01 = elemAt list 2 == X;\n  ex02 = length list == X;\n  ex03 = last list == X;\n  ex04 = filter f list == [ XX ];\n  ex05 = head list == X;\n  ex06 = tail list == [ XXX ];\n  ex07 = remove true list == [ XXX ];\n  ex08 = toList s == [ XXX ];\n  ex09 = take 3 list == [ XXX ];\n  ex10 = drop 4 list == [ XXX ];\n  ex11 = unique list == [ XXX ];\n  ex12 = list ++ [\"x\" \"y\"] == [ XXX ];\n}\n","question":"To learn the basic syntax replace every XX in the function body with values from the let scope.\n\n\nEvery exercise should evaluate to true.","solution":"with import <nixpkgs> { };\nwith stdenv.lib;\nlet\n  list = [2 \"4\" true true {a = 27;} 2];\n  f = x: isString x;\n  s = \"foobar\";\nin\n{\n  #replace all X, everything should evaluate to true\n  ex00 = isList list;\n  ex01 = elemAt list 2 == true;\n  ex02 = length list == 6;\n  ex03 = last list == 2;\n  ex04 = filter f list == [\"4\"];\n  ex05 = head list == 2;\n  ex06 = tail list == [\"4\" true true {a = 27;} 2];\n  ex07 = remove true list == [2 \"4\" {a = 27;} 2];\n  ex08 = toList s == [s];\n  ex09 = take 3 list == [2 \"4\" true];\n  ex10 = drop 4 list == [{a = 27;} 2];\n  ex11 = unique list == [2 \"4\" true {a = 27;}];\n  ex12 = list ++ [\"x\" \"y\"] == [2 \"4\" true true {a = 27;} 2 \"x\" \"y\"];\n}\n","topic":"Lists"},{"code":"let \n  myImport = import <nixpkgs> {};\n  x = 123; \n  as = { a = \"foo\"; b = \"bar\"; };\n  \nin with as; { \n  inherit x; #example\n  #fix line below: we want a and b in this scope\n  inherit X; \n  #also fix this line\n  z = XXX.lib.isBool true;\n}\n","question":"These 3 keywords can be confused pretty easily. Since we are using them\na lot in `A tour of Nix` we need to introduce them properly.\n\n## With\n\nA with-expression, introduces the `set e1` into the lexical scope of the `expression e2`. \n\n    let \n      as = { x = \"foo\"; y = \"bar\"; };\n    in \n      with as; x + y\n\n## Import\n\nLoad, parse and return the Nix expression in the file path. \n`import` implements Nixâ€™s module system: you can put any Nix expression (such as a set or a function) in a separate file, and use it from Nix expressions in other files.\n\n    rec {\n      x = 123;\n      y = import ./foo.nix;\n    }\n\n## Inherit\nThe `inherit` keyword causes the specified `attributes` to be bound to whatever \nvariables with the same name happen to be in scope.\n\n    let \n      x = 123; \n    in\n    { \n      inherit x;\n      y = 456;\n    }\n","solution":"let \n  myImport = import <nixpkgs> {};\n  x = 123; \n  as = { a = \"foo\"; b = \"bar\"; };\n  \nin with as; { \n  inherit x;\n  inherit a b;\n  z = myImport.lib.isBool true;\n}\n","topic":"Inheriting with imports-confusion!"},{"code":"let\n  x = 123;\n  as = { a = \"foo\"; b = \"bar\"; x=\"234\"; };\n \nin with as; {\n res = x; # what value is res bound to?\n}\n\n","question":"This question is about scopes. `let` binds `attributes` as well as `with` does.\n\nQuestion: Which value is `res` assinged to and why?\n\nSolution: See the `solution` button's associated source code.\n\n","solution":"# most ppl would assume that x would be bound to \"234\" because it was\n# introduced last (`with as`). but instead it is bound to 123; which was\n# introduced by `let`\n\n# the motivation for this is:\n\n# file1.nix\n\n# {\n# pkg1 = ...\n# pkg2 = ...\n#\n# ...\n#\n# }\n\n\n# file2.nix\n\n# let\n# pkg256 = ...\n\n# in\n\n# with import file1.nix;\n# pkg256\n\n{ res = 123; }\n","topic":"Scoping of attributes in let/with"},{"code":"let\n  bar = [\"bar\" \"foo\" \"bla\"];\n  numbers = [1 2 3 4];\nin\n{\n  #multiplies every number by 2\n  example = map (n: n * 2) numbers; \n  #complete this\n#  foobar = map ( XXX ) XXXX;\n}\n","question":"A function called `builtin.map` exists.\n\nThe `map-function` requires these arguments: a `function` and a `list`. \nIt evaluates the given function on every element of the given list. \n\nIn the example it is used to multiply \nevery number in a list with 2. \n\nYour job:\n\n* Use the map function to extend every `string` in **bar** with \"bar\". \n\n**Note:** You can modify the `Strings` in any way. \nThey don't have to evaluate to 'foobar' (nor should they).","solution":"let\n  bar = [\"bar\" \"foo\" \"bla\"];\n  numbers = [1 2 3 4];\nin\n{\n  #multiplies every number by 2\n  example = map (n: n * 2) numbers; \n  #complete this\n  foobar = map (x: x + \"bar\") bar;\n}","topic":"Map"},{"code":"with import <nixpkgs> { };\nlet\n  list = [\"a\" \"b\" \"a\" \"c\" \"d\" \"a\"];\n  countA = lib.fold XXX;\nin\nrec {\n  example = lib.fold (x: y: x + y) \"\" [\"a\" \"b\" \"c\"]; #is \"abc\"\n  result = countA list; #should be 3\n}\n","question":"`Fold` is a binary function that uses the function 'f' between successive \nelements of `list` with 'z' as the starting value,\n\ni.e., `fold f z [x_1 x_2 ... x_n] == f x_1 (f x_2 ... (f x_n z))`\n\n![image depicting a fold operation](https://upload.wikimedia.org/wikipedia/\ncommons/3/3e/Right-fold-transformation.png \"fold visualized\")\n\n**Note:** There is **fold left** and **fold right** and `lib.fold` \nimplements **fold right**.\n\n**Note:** More information about `fold` can be found at: \n[Wikipedia](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29) \nfrom where we copied the image. \n\nNow:  \n\n* use `fold` to write a function that counts all `strings` \nwith value \"a\" in a given `list`.\n\n","solution":"\n# use fold to write a function that counts all \"a\" in a list\nwith import <nixpkgs> { };\nlet\n  list = [\"a\" \"b\" \"a\" \"c\" \"d\" \"a\"];\n  countA = lib.fold (x: y: if x == \"a\" then 1 + y else y) 0;\nin\nrec {\n  example = lib.fold (x: y: x + y) \"\" [\"a\" \"b\" \"c\"]; #is \"abc\"\n  result = countA list; #should be 3\n}\n\n\n","topic":"Fold: Introduction"},{"code":"with import <nixpkgs> { }; \nrec {\n  made_it = \"it is done\";\n}\n","question":"## It is done!\nCongratulations! You reached the end of this course and you made it!\n\n**We hope you liked 'A tour of Nix'!** If you want to **contact us**, \nplease write an email to either:\n\n* [Joachim Schiele](mailto:js@lastlog.de)\n* [Paul Seitz](mailto:paul.m.seitz@gmail.com)\n\n\n## Further reading\n\n* [Nix by example - Part 1](https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55)\n\n  Parse trees, evaluation order, composite data-types, laziness, conditionals, Let expressions, and much more...\n\n* [Luca Bruno's nix pill(s)](http://lethalman.blogspot.de/2014/07/nix-pill-1-why-you-should-give-it-try.html)\n  \n  The Nix Pills are a wonderful introduction into Nix programming and you will \n  have much joy reading them!\n  \n* [NixPkgs manual](https://nixos.org/nixpkgs/manual) \n\n  Covers topics as: buildPhases, override(s) and support for specific \n  programming languages\n \n* [NixOS Wiki](https://nixos.org/wiki/Main_Page)\n\n  The Wiki contains a lot of practical articles, like the \n  [Cheatsheet](https://nixos.org/wiki/Cheatsheet)\n\n\n## Contributing\n\nNow this is actually quite easy! \n\n ??PAYPAL??\n\n### Manual editing\nDownload <https://nixcloud.io/tour/questions.json> and open it in the \neditor of your choise.\n\n### Using the inline editor\n\nShortcuts:\n\n* `ctrl+,` - loads markdown into the editor\n* `ctrl+.` - compiles markdown2html into the right side\n\n  **Note:** do this twice and the editor is restored to the previous state!\n\n* `ctrl+i` - reset the editor to the default content\n* `ctrl+s` - save the questions to `questions.json` into you \n  `downloads` directory\n  \nIf you want to add new questions, use the javascript console. \n\n**Warning:** `ctrl+shift+i` won't work in chrome, so use the mouse with \nRMB to `inspect element`. From that javascript console you can extend the `questions` \nobject, which holds all the questions.\n\n**Warning:** You might want to play with the workflow for some time as\nyou can easily 'overwrite' or 'reset' your contributions by accident!","solution":"with import <nixpkgs> { }; \nrec {\n  made_it = \"it is done\";\n}\n","topic":"The end"}]